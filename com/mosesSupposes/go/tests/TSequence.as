package com.mosesSupposes.go.tests {	import flash.display.Sprite;
	import flash.events.MouseEvent;
	
	import org.goasap.PlayableBase;
	import org.goasap.events.GoEvent;
	import org.goasap.events.SequenceEvent;
	import org.goasap.interfaces.IPlayable;
	import org.goasap.utils.Sequence;
	
	import com.mosesSupposes.go.tutorials.SizeTweenMG;
	
	import fl.controls.Button;
	import fl.motion.easing.Back;	
	// Extensions of Go should live in your personal classpath!		/**	 * @author Moses Gunesch	 */	public class TSequence extends GoTestBase {				protected var box1 : Sprite;		protected var box2 : Sprite;		protected var box3 : Sprite;		protected var box4 : Sprite;		/**		There are 2 Sequence classes included in Go, Sequence and SequenceCA.		 		The Sequence class composes a sequence from SequenceStep instances.		It allows you to add any playable item to it, wrapping items		in SequenceSteps as you build the sequence. Like most elements of		Go, Sequences are playable and dispatch events, Sequence dispatches		one unique event, SequenceEvent.ADVANCE, as it steps forward, as well		as dispatching normal GoEvents like COMPLETE.				There's another example FLA that shows the slightly more advanced SequenceCA.				 */		public function TSequence() 		{			// Make a sequence & add some listeners.			// (Note: Sequences should not get GC'd during play even if a reference is not retained in the class.)			var seq : Sequence = new Sequence();			seq.playableID = "seq";						// You can loop the sequence using its repeater instance.			// Set it to Repeater.INFINITE for indefinite looping until seq.stop() is called.			// To query which loop it is on, use seq.repeater.currentCycle			seq.repeater.cycles = 2; // default is 1.						seq.addEventListener(GoEvent.START, super.traceEvent);			seq.addEventListener(GoEvent.STOP, super.traceEvent);			seq.addEventListener(GoEvent.PAUSE, super.traceEvent);			seq.addEventListener(GoEvent.RESUME, super.traceEvent);			seq.addEventListener(GoEvent.CYCLE, super.traceEvent);			seq.addEventListener(GoEvent.COMPLETE, super.traceEvent);			seq.addEventListener(SequenceEvent.ADVANCE, super.traceEvent);						box1 = box(20);			box2 = box(40);			box3 = box(60);			box4 = box(80);			var t1 : SizeTweenMG = new SizeTweenMG(box1, 200, NaN, 0, 1, Back.easeOut);			t1.startWidth = 10;			// stick the tween in the sequence.			seq.addStep(t1);						// (internally, the sequence automatically wraps the 			//  tween in a SequenceStep instance, which is actually a group.)			var t2 : SizeTweenMG = new SizeTweenMG(box2, 200, NaN, 0, 1, Back.easeOut);			t2.startWidth = 10;			seq.addStep(t2);									var t3 : SizeTweenMG = new SizeTweenMG(box3, 200, NaN, 0, 1, Back.easeOut);			t3.startWidth = 10;			// You can also create groups within sequences really easily by 			// passing true to the second parameter, << addToLastStep >>. 			seq.addStep(t3, true);						// (You could also create a PlayableGroup or SequenceStep and then			//  add that to the sequence, the above is just a shortcut.)			var t4 : SizeTweenMG = new SizeTweenMG(box4, 200, NaN, 0, 1, Back.easeOut);			t4.startWidth = 10;						// Methods like addStepAt() and removeStepAt() let you work with the			// sequence array, you can also retrieve all SequenceSteps with seq.steps.			seq.addStepAt(t4, 3);									super.addHeaderText("Sequence: each step can be comoposed of one or more playable items.\n" +								"The 2nd & 3rd targets are grouped into a step.\n" +								"Note that calling skipTo on a sequence skips to that play index.");			super.addButtonUI(seq, 1);		}						// The following code runs a reset when you click start() or skipTo().		// skipTo() doesn't reset box1 since we're skipping to the second index.				override protected function onClick(e : MouseEvent) : void 		{			var button:Button = e.target as Button;			var playable:IPlayable = buttonTargets[button] as IPlayable;			if (playable==null)				return;						if (button.label=="start" || button.label.indexOf("skipTo")==0) {				resetTargets(button.label=="start");			}			super.onClick(e);		}				protected function resetTargets(isStart:Boolean=false) : void {			if (isStart) { // 				box1.width = 10;			}			box2.width = 10;			box3.width = 10;			box4.width = 10;		}	}}